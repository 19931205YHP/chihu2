{"version":3,"sources":["../../src/pages/my-collect/my-collect.module.ts","webpack:///./~/ionic2-super-tabs/dist/components/super-tabs.js?fb4a**","webpack:///./~/ionic2-super-tabs/dist/providers/super-tabs-controller.js?8660**","webpack:///./~/ionic2-super-tabs/dist/components/super-tab-button.js?e987**","webpack:///./~/ionic2-super-tabs/dist/components/super-tab.js?aa74**","webpack:///./~/ionic2-super-tabs/dist/components/super-tabs-container.js?32b5**","webpack:///./~/ionic2-super-tabs/dist/components/super-tabs-toolbar.js?b87b**","webpack:///./~/ionic2-super-tabs/dist/super-tabs-pan-gesture.js?d171**","webpack:///./~/ionic2-super-tabs/dist/index.js?acab**","webpack:///./~/ionic2-super-tabs/dist/super-tabs.module.js?28c4**","webpack:///./~/rxjs/Scheduler.js?39fa**","webpack:///./~/rxjs/add/observable/merge.js?ea2b**","webpack:///./~/rxjs/add/operator/debounceTime.js?98ae**","webpack:///./~/rxjs/operator/debounceTime.js?9383**","webpack:///./~/rxjs/scheduler/Action.js?c51a**","webpack:///./~/rxjs/scheduler/AsyncAction.js?1188**","webpack:///./~/rxjs/scheduler/AsyncScheduler.js?cd30**","webpack:///./~/rxjs/scheduler/async.js?43d3**","../../src/pages/my-collect/my-collect.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAyC;AACO;AACH;AACO;AAcpD,IAAa,mBAAmB;IAAhC;IAAkC,CAAC;IAAD,0BAAC;AAAD,CAAC;AAAtB,mBAAmB;IAZ/B,sFAAQ,CAAC;QACR,YAAY,EAAE;YACZ,kEAAa;SACd;QACD,OAAO,EAAE;YACP,sEAAe,CAAC,QAAQ,CAAC,kEAAa,CAAC;YACvC,0EAAe,CAAC,OAAO,EAAE;SAC1B;QACD,OAAO,EAAE;YACP,kEAAa;SACd;KACF,CAAC;GACW,mBAAmB,CAAG;AAAH;;;;;;;;;;;;;;;;;;;;;;;ACjB4F;AAC1C;AAC7D;AACM;AACE;AACC;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uCAAuC,EAAE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B,0BAA0B,OAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,+BAA+B,+BAA+B;AAC9D;AACA,uBAAuB,6CAA6C;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+BAA+B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iBAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,4BAA4B,EAAE;AAClF;AACA;AACA,+CAA+C,4BAA4B,EAAE;AAC7E;AACA;AACA;AACA;AACA;AACA,qDAAqD,gBAAgB;AACrE;AACA,gDAAgD,aAAa;AAC7D;AACA,mDAAmD;AACnD;AACA,mDAAmD;AACnD;AACA,yDAAyD;AACzD;AACA,CAAC;AACO;AACR;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,4IAA6D,kBAAkB,EAAE;AACjF;AACA;AACA,aAAa,IAAI;AACjB;AACA;AACA,wCAAwC;AACxC,KAAK,2FAAoC,wEAAiB,IAAI;AAC9D,KAAK,4FAAqC,wEAAiB,IAAI;AAC/D,KAAK,oEAAa;AAClB,KAAK,2EAAoB;AACzB,KAAK,4EAAmB;AACxB,KAAK,uGAA6B;AAClC,KAAK,2EAAoB;AACzB,KAAK,8EAAuB;AAC5B,EAAE;AACF;AACA,2BAA2B,qEAAc;AACzC,sBAAsB,qEAAc;AACpC,wBAAwB,qEAAc;AACtC,oBAAoB,qEAAc;AAClC,gBAAgB,qEAAc;AAC9B,YAAY,qEAAc;AAC1B,gBAAgB,qEAAc;AAC9B,0BAA0B,qEAAc;AACxC,oBAAoB,qEAAc;AAClC,uBAAuB,qEAAc;AACrC,mBAAmB,uEAAe;AAClC,iBAAiB,mKAA6C;AAC9D,uBAAuB,uKAA+C;AACtE;AACA;AACA,sC;;;;;;;;;;ACngBqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA;AACA,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,2BAA2B,EAAE;AAC1F;AACA;AACA;AACA;AACA;AACA,CAAC;AACO;AACR;AACA,KAAK,0EAAmB;AACxB;AACA;AACA,kDAAkD,WAAW;AAC7D,iD;;;;;;;;;;AC9EyG;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACO;AACR;AACA,KAAK;AACL;AACA,oLAAoL,SAAS,6DAA6D,SAAS,qDAAqD,4BAA4B,KAAK,SAAS;AAClW;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa,IAAI;AACjB;AACA;AACA,6CAA6C;AAC7C,KAAK,2EAAoB;AACzB,EAAE;AACF;AACA,kBAAkB,qEAAc;AAChC,eAAe,qEAAc;AAC7B,cAAc,qEAAc;AAC5B,eAAe,qEAAc;AAC7B,oBAAoB,qEAAc;AAClC,eAAe,qEAAc;AAC7B,gBAAgB,uEAAe;AAC/B;AACA,4C;;;;;;;;;;;;AC9CA;AAAA;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AAC6K;AAC7E;AAClE;AACX;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,qDAAqD,oCAAoC,EAAE;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,iBAAiB;AAC3E;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACO;AACR;AACA,KAAK;AACL;AACA;AACA;AACA,aAAa,IAAI;AACjB;AACA;AACA,uCAAuC;AACvC,KAAK,wEAAmB;AACxB,KAAK,oEAAa;AAClB,KAAK,uEAAgB;AACrB,KAAK,yEAAkB;AACvB,KAAK,2EAAoB;AACzB,KAAK,uEAAgB;AACrB,KAAK,yEAAkB;AACvB,KAAK,yFAAkC;AACvC,KAAK,kFAA2B;AAChC,KAAK,uHAA8B;AACnC,KAAK,6EAAsB;AAC3B,KAAK,wFAAiC,wEAAiB,IAAI;AAC3D,KAAK,8EAAuB;AAC5B,KAAK,kFAA2B;AAChC,EAAE;AACF;AACA,eAAe,qEAAc;AAC7B,cAAc,qEAAc;AAC5B,cAAc,qEAAc;AAC5B,oBAAoB,qEAAc;AAClC,eAAe,oFAA6B;AAC5C,eAAe,qEAAc;AAC7B,0BAA0B,qEAAc;AACxC,aAAa,+FAAsC,gFAAyB,IAAI;AAChF;AACA,qC;;;;;;;;;;;;AC/J8G;AAC3F;AACW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,sCAAsC,uCAAuC,EAAE,EAAE,EAAE;AACxJ,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yDAAyD;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gBAAgB;AACjD,kCAAkC,6DAA6D,EAAE;AACjG;AACA;AACA,iCAAiC,iBAAiB;AAClD,kCAAkC,yBAAyB,GAAG;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACO;AACR;AACA,KAAK;AACL;AACA;AACA;AACA,aAAa,IAAI;AACjB;AACA;AACA,iDAAiD;AACjD,KAAK,2EAAoB;AACzB,KAAK,4EAAmB;AACxB,KAAK,yEAAkB;AACvB,KAAK,uEAAgB;AACrB,EAAE;AACF;AACA,gBAAgB,qEAAc;AAC9B,mBAAmB,qEAAc;AACjC,0BAA0B,qEAAc;AACxC,mBAAmB,uEAAe;AAClC,gBAAgB,uEAAe;AAC/B,mBAAmB,iGAAwC;AAC3D;AACA,gD;;;;;;;;;;;;;AC1KoH;AAClF;AACJ;AACL;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,CAAC;AACO;AACR;AACA,KAAK;AACL;AACA,yPAAyP,iCAAiC,4HAA4H,6TAA6T,iCAAiC;AACpvB;AACA,aAAa,IAAI;AACjB;AACA;AACA,+CAA+C;AAC/C,KAAK,2EAAoB;AACzB,KAAK,yEAAkB;AACvB,KAAK,4EAAmB;AACxB,KAAK,8EAAuB;AAC5B,EAAE;AACF;AACA,eAAe,qEAAc;AAC7B,mBAAmB,qEAAc;AACjC,oBAAoB,qEAAc;AAClC,oBAAoB,qEAAc;AAClC,wBAAwB,qEAAc;AACtC,qBAAqB,qEAAc;AACnC,gBAAgB,qEAAc;AAC9B,uBAAuB,qEAAc;AACrC,mBAAmB,uEAAe;AAClC,oBAAoB,kKAA8C;AAClE,6BAA6B,2GAAkD;AAC/E,mBAAmB,iGAAwC;AAC3D,uBAAuB,kGAAyC;AAChE;AACA,8C;;;;;;;;;;AC5IuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,aAAa,EAAE;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACO;AACR,kD;;;;;;;;;;;;;;;;ACpFA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;;;;;;;ACJmB;AACG;AACH;AACC;AACU;AACH;AACE;AACJ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACO;AACR;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB;AACA;AACA,8CAA8C,WAAW;AACzD,6C;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,aAAa;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qBAAqB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mCAAmC;AAClD;AACA,eAAe,OAAO;AACtB;AACA,eAAe,EAAE;AACjB;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA,+BAA+B,WAAW;AAC1C;AACA;AACA,uDAAuD,oBAAoB;AAC3E;AACA,CAAC;AACD;AACA,qC;;;;;;;;AChDA;AACA;AACA;AACA;AACA,iC;;;;;;;;ACJA;AACA;AACA;AACA;AACA,wC;;;;;;;;ACJA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,YAAY;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,iBAAiB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA,WAAW,UAAU,wBAAwB,iBAAiB;AAC9D;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,wC;;;;;;;;ACnHA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA,uCAAuC,gBAAgB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB;AAChB;AACA;AACA,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA,CAAC;AACD;AACA,kC;;;;;;;;AC3CA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,uC;;;;;;;;AC7IA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,kCAAkC;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,0C;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,WAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;;;;;;;;;;;AC9C0C;AAC0B;AACY;AAEhF;;;;;GAKG;AAMH,IAAa,aAAa;IASxB,uBAAmB,WAAgC,EAAS,OAAsB,EAAS,SAAoB;QAA5F,gBAAW,GAAX,WAAW,CAAqB;QAAS,YAAO,GAAP,OAAO,CAAe;QAAS,cAAS,GAAT,SAAS,CAAW;QAP/G,UAAK,GAAQ,iBAAiB,CAAC;QAC/B,UAAK,GAAQ,mBAAmB,CAAC;QACjC,QAAG,GAAG,CAAC,CAAC;QACR,eAAU,GAAG;YACX,GAAG,EAAE,IAAI,CAAC,GAAG;SACd,CAAC;QAIA,EAAE,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YAC7B,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;YACpC,IAAI,CAAC,UAAU,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC;QACjC,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,IAAI,CAAC,UAAU,CAAC,GAAG,GAAG,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,GAAG,CAAC;QACnD,CAAC;IAEH,CAAC;IAEH,oBAAC;AAAD,CAAC;AApBY,aAAa;IALzB,uFAAS,EAAE;IACX,wFAAS,CAAC;QACT,QAAQ,EAAE,iBAAiB;OACG;KAC/B,CAAC;kBAU+G;AAWhH;SApBY,aAAa,gB","file":"3.main.js","sourcesContent":["import { NgModule } from '@angular/core';\nimport { IonicPageModule } from 'ionic-angular';\nimport { MyCollectPage } from './my-collect';\nimport { SuperTabsModule } from 'ionic2-super-tabs';\n\n@NgModule({\n  declarations: [\n    MyCollectPage,\n  ],\n  imports: [\n    IonicPageModule.forChild(MyCollectPage),\n    SuperTabsModule.forRoot()\n  ],\n  exports: [\n    MyCollectPage\n  ]\n})\nexport class MyCollectPageModule {}\n\n\n\n// WEBPACK FOOTER //\n// ./src/pages/my-collect/my-collect.module.ts","import { Component, ElementRef, Input, Renderer2, ViewChild, Output, EventEmitter, ViewEncapsulation, forwardRef, Optional } from '@angular/core';\r\nimport { NavController, RootNode, ViewController, App, DeepLinker, DomController } from 'ionic-angular';\r\nimport { Observable } from 'rxjs/Observable';\r\nimport { SuperTabsToolbar } from './super-tabs-toolbar';\r\nimport { SuperTabsContainer } from './super-tabs-container';\r\nimport { SuperTabsController } from '../providers/super-tabs-controller';\r\nimport 'rxjs/add/observable/fromEvent';\r\nimport 'rxjs/add/observable/merge';\r\nimport 'rxjs/add/operator/debounceTime';\r\nvar SuperTabs = (function () {\r\n    function SuperTabs(parent, viewCtrl, _app, el, rnd, superTabsCtrl, linker, domCtrl) {\r\n        var _this = this;\r\n        this.viewCtrl = viewCtrl;\r\n        this._app = _app;\r\n        this.el = el;\r\n        this.rnd = rnd;\r\n        this.superTabsCtrl = superTabsCtrl;\r\n        this.linker = linker;\r\n        this.domCtrl = domCtrl;\r\n        /**\r\n         * Color of the slider that moves based on what tab is selected\r\n         */\r\n        this.indicatorColor = 'primary';\r\n        /**\r\n         * Badge color\r\n         */\r\n        this.badgeColor = 'primary';\r\n        /**\r\n         * Configuration\r\n         */\r\n        this.config = {};\r\n        /**\r\n         * Tab buttons placement. Can be `top` or `bottom`.\r\n         * @type {string}\r\n         */\r\n        this.tabsPlacement = 'top';\r\n        /**\r\n         * Emits the tab index when the selected tab changes\r\n         * @type {EventEmitter<Object>}\r\n         */\r\n        this.tabSelect = new EventEmitter();\r\n        /**\r\n         * Indicates whether the toolbar is visible\r\n         * @private\r\n         */\r\n        this._isToolbarVisible = true;\r\n        /**\r\n         * @private\r\n         */\r\n        this._tabs = [];\r\n        /**\r\n         * Indicates whether the tab buttons should scroll\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._scrollTabs = false;\r\n        /**\r\n         * Selected tab index\r\n         * @type {number}\r\n         * @private\r\n         */\r\n        this._selectedTabIndex = 0;\r\n        /**\r\n         * Any observable subscriptions that we should unsubscribe from when destroying this component\r\n         * @type {Array<Subscription>}\r\n         * @private\r\n         */\r\n        this.watches = [];\r\n        /**\r\n         * Indicates whether any of the tabs has an icon\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this.hasIcons = false;\r\n        /**\r\n         * Indicates whether any of the tabs has a title\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this.hasTitles = false;\r\n        /**\r\n         * Indicates whether the component has finished initializing\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this.init = false;\r\n        this.parent = parent;\r\n        if (this.parent) {\r\n            this.parent.registerChildNav(this);\r\n        }\r\n        else if (viewCtrl && viewCtrl.getNav()) {\r\n            this.parent = viewCtrl.getNav();\r\n            this.parent.registerChildNav(this);\r\n        }\r\n        else if (this._app) {\r\n            this._app._setRootNav(this);\r\n        }\r\n        var obsToMerge = [\r\n            Observable.fromEvent(window, 'orientationchange'),\r\n            Observable.fromEvent(window, 'resize')\r\n        ];\r\n        if (viewCtrl) {\r\n            viewCtrl._setContent(this);\r\n            viewCtrl._setContentRef(el);\r\n            obsToMerge.push(viewCtrl.didEnter);\r\n        }\r\n        // re-adjust the height of the slider when the orientation changes\r\n        this.watches.push(Observable.merge.apply(this, obsToMerge)\r\n            .debounceTime(10)\r\n            .subscribe(function () {\r\n            _this.setMaxIndicatorPosition();\r\n            _this.updateTabWidth();\r\n            _this.setFixedIndicatorWidth();\r\n            _this.refreshTabWidths();\r\n            _this.tabsContainer.refreshDimensions();\r\n            _this.tabsContainer.slideTo(_this.selectedTabIndex);\r\n            _this.alignIndicatorPosition();\r\n            _this.refreshContainerHeight();\r\n        }));\r\n    }\r\n    Object.defineProperty(SuperTabs.prototype, \"height\", {\r\n        get: function () {\r\n            return this.el.nativeElement.offsetHeight;\r\n        },\r\n        /**\r\n         * Height of the tabs\r\n         */\r\n        set: function (val) {\r\n            this.rnd.setStyle(this.el.nativeElement, 'height', val + 'px');\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(SuperTabs.prototype, \"selectedTabIndex\", {\r\n        get: function () {\r\n            return this._selectedTabIndex;\r\n        },\r\n        /**\r\n         * The initial selected tab index\r\n         * @param val {number} tab index\r\n         */\r\n        set: function (val) {\r\n            this._selectedTabIndex = Number(val);\r\n            this.init && this.alignIndicatorPosition(true);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(SuperTabs.prototype, \"scrollTabs\", {\r\n        get: function () {\r\n            return this._scrollTabs;\r\n        },\r\n        /**\r\n         * Set to true to enable tab buttons scrolling\r\n         * @param val\r\n         */\r\n        set: function (val) {\r\n            this._scrollTabs = typeof val !== 'boolean' || val === true;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    SuperTabs.prototype.ngOnInit = function () {\r\n        var defaultConfig = {\r\n            dragThreshold: 10,\r\n            maxDragAngle: 40,\r\n            sideMenuThreshold: 50,\r\n            transitionDuration: 300,\r\n            transitionEase: 'cubic-bezier(0.35, 0, 0.25, 1)',\r\n            shortSwipeDuration: 300\r\n        };\r\n        for (var prop in this.config) {\r\n            defaultConfig[prop] = this.config[prop];\r\n        }\r\n        this.config = defaultConfig;\r\n        this.id = this.id || \"super-tabs-\" + ++superTabsIds;\r\n        this.superTabsCtrl.registerInstance(this);\r\n        if (this.tabsPlacement === 'bottom') {\r\n            this.rnd.addClass(this.getElementRef().nativeElement, 'tabs-placement-bottom');\r\n        }\r\n    };\r\n    SuperTabs.prototype.ngAfterContentInit = function () {\r\n        this.updateTabWidth();\r\n        this.toolbar.tabs = this._tabs;\r\n    };\r\n    SuperTabs.prototype.ngAfterViewInit = function () {\r\n        var _this = this;\r\n        var tabsSegment = this.linker.initNav(this);\r\n        if (tabsSegment && !tabsSegment.component) {\r\n            this.selectedTabIndex = this.linker.getSelectedTabIndex(this, tabsSegment.name, this.selectedTabIndex);\r\n        }\r\n        this.linker.navChange('switch');\r\n        if (!this.hasTitles && !this.hasIcons)\r\n            this._isToolbarVisible = false;\r\n        this.tabsContainer.slideTo(this.selectedTabIndex, false);\r\n        this.refreshTabStates();\r\n        this.setFixedIndicatorWidth();\r\n        // we need this to make sure the \"slide\" thingy doesn't move outside the screen\r\n        this.setMaxIndicatorPosition();\r\n        setTimeout(function () { return _this.alignIndicatorPosition(); }, 100);\r\n        this.refreshContainerHeight();\r\n        this.init = true;\r\n    };\r\n    SuperTabs.prototype.ngOnDestroy = function () {\r\n        this.watches.forEach(function (watch) {\r\n            watch.unsubscribe && watch.unsubscribe();\r\n        });\r\n        this.parent.unregisterChildNav(this);\r\n        this.superTabsCtrl.unregisterInstance(this.id);\r\n    };\r\n    /**\r\n     * Sets the badge number for a specific tab\r\n     * @param tabId {string} tab ID\r\n     * @param value {number} badge number\r\n     */\r\n    SuperTabs.prototype.setBadge = function (tabId, value) {\r\n        this.getTabById(tabId).setBadge(value);\r\n    };\r\n    /**\r\n     * Clears the badge for a specific tab\r\n     * @param tabId {string} tab ID\r\n     */\r\n    SuperTabs.prototype.clearBadge = function (tabId) {\r\n        this.getTabById(tabId).clearBadge();\r\n    };\r\n    /**\r\n     * Increases the badge value for a specific tab\r\n     * @param tabId {string} tab ID\r\n     * @param increaseBy {number} the number to increase by\r\n     */\r\n    SuperTabs.prototype.increaseBadge = function (tabId, increaseBy) {\r\n        this.getTabById(tabId).increaseBadge(increaseBy);\r\n    };\r\n    SuperTabs.prototype.decreaseBadge = function (tabId, decreaseBy) {\r\n        this.getTabById(tabId).decreaseBadge(decreaseBy);\r\n    };\r\n    SuperTabs.prototype.enableTabsSwipe = function (enable) {\r\n        this.tabsContainer.enableTabsSwipe(enable);\r\n    };\r\n    SuperTabs.prototype.enableTabSwipe = function (tabId, enable) {\r\n        this.tabsContainer.enableTabSwipe(this.getTabIndexById(tabId), enable);\r\n    };\r\n    SuperTabs.prototype.showToolbar = function (show) {\r\n        this._isToolbarVisible = show;\r\n        this.refreshContainerHeight();\r\n    };\r\n    SuperTabs.prototype.slideTo = function (indexOrId) {\r\n        if (typeof indexOrId === 'string') {\r\n            indexOrId = this.getTabIndexById(indexOrId);\r\n        }\r\n        this.selectedTabIndex = indexOrId;\r\n        this.tabsContainer.slideTo(indexOrId);\r\n    };\r\n    SuperTabs.prototype.getActiveChildNav = function () {\r\n        return this._tabs[this.selectedTabIndex];\r\n    };\r\n    SuperTabs.prototype.addTab = function (tab) {\r\n        tab.rootParams = tab.rootParams || {};\r\n        tab.rootParams.rootNavCtrl = this.parent;\r\n        tab.tabId = tab.tabId || \"super-tabs-\" + this.id + \"-tab-\" + this._tabs.length;\r\n        this._tabs.push(tab);\r\n        if (tab.icon) {\r\n            this.hasIcons = true;\r\n        }\r\n        if (tab.title) {\r\n            this.hasTitles = true;\r\n        }\r\n        tab.setWidth(this.el.nativeElement.offsetWidth);\r\n    };\r\n    /**\r\n     * We listen to drag events to move the \"slide\" thingy along with the slides\r\n     */\r\n    SuperTabs.prototype.onDrag = function () {\r\n        var _this = this;\r\n        if (!this._isToolbarVisible)\r\n            return;\r\n        this.domCtrl.write(function () {\r\n            var singleSlideWidth = _this.tabsContainer.tabWidth, slidesWidth = _this.tabsContainer.containerWidth;\r\n            var percentage = Math.abs(_this.tabsContainer.containerPosition / slidesWidth);\r\n            if (_this.scrollTabs) {\r\n                var originalSlideStart = singleSlideWidth * _this.selectedTabIndex, originalPosition = _this.getRelativeIndicatorPosition(), originalWidth = _this.getSegmentButtonWidth();\r\n                var nextPosition = void 0, nextWidth = void 0, indicatorPosition = void 0, indicatorWidth = void 0;\r\n                var deltaTabPos = originalSlideStart - Math.abs(_this.tabsContainer.containerPosition);\r\n                percentage = Math.abs(deltaTabPos / singleSlideWidth);\r\n                if (deltaTabPos < 0) {\r\n                    // going to next slide\r\n                    nextPosition = _this.getRelativeIndicatorPosition(_this.selectedTabIndex + 1);\r\n                    nextWidth = _this.getSegmentButtonWidth(_this.selectedTabIndex + 1);\r\n                    indicatorPosition = originalPosition + percentage * (nextPosition - originalPosition);\r\n                }\r\n                else {\r\n                    // going to previous slide\r\n                    nextPosition = _this.getRelativeIndicatorPosition(_this.selectedTabIndex - 1);\r\n                    nextWidth = _this.getSegmentButtonWidth(_this.selectedTabIndex - 1);\r\n                    indicatorPosition = originalPosition - percentage * (originalPosition - nextPosition);\r\n                }\r\n                var deltaWidth = nextWidth - originalWidth;\r\n                indicatorWidth = originalWidth + percentage * deltaWidth;\r\n                if ((originalWidth > nextWidth && indicatorWidth < nextWidth) || (originalWidth < nextWidth && indicatorWidth > nextWidth)) {\r\n                    // this is only useful on desktop, because you are able to drag and swipe through multiple tabs at once\r\n                    // which results in the indicator width to be super small/big since it's changing based on the current/next widths\r\n                    indicatorWidth = nextWidth;\r\n                }\r\n                _this.alignTabButtonsContainer();\r\n                _this.toolbar.setIndicatorProperties(indicatorWidth, indicatorPosition);\r\n            }\r\n            else {\r\n                _this.toolbar.setIndicatorPosition(Math.min(percentage * singleSlideWidth, _this.maxIndicatorPosition));\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Runs when the user clicks on a segment button\r\n     * @param index\r\n     */\r\n    SuperTabs.prototype.onTabChange = function (index) {\r\n        if (index <= this._tabs.length) {\r\n            var currentTab = this.getActiveTab();\r\n            var activeView = currentTab.getActive();\r\n            if (activeView) {\r\n                activeView._willLeave(false);\r\n                activeView._didLeave();\r\n            }\r\n            this.selectedTabIndex = index;\r\n            this.linker.navChange('switch');\r\n            this.refreshTabStates();\r\n            activeView = this.getActiveTab().getActive();\r\n            if (activeView) {\r\n                activeView._willEnter();\r\n                activeView._didEnter();\r\n            }\r\n            this.tabSelect.emit({\r\n                index: index,\r\n                id: this._tabs[index].tabId\r\n            });\r\n        }\r\n    };\r\n    SuperTabs.prototype.onToolbarTabSelect = function (index) {\r\n        this.tabsContainer.slideTo(index);\r\n        this.onTabChange(index);\r\n    };\r\n    SuperTabs.prototype.onContainerTabSelect = function (ev) {\r\n        if (ev.changed) {\r\n            this.onTabChange(ev.index);\r\n        }\r\n        this.alignIndicatorPosition(true);\r\n    };\r\n    SuperTabs.prototype.refreshTabStates = function () {\r\n        var _this = this;\r\n        this._tabs.forEach(function (tab, i) {\r\n            tab.setActive(i === _this.selectedTabIndex);\r\n            tab.load(Math.abs(_this.selectedTabIndex - i) < 2);\r\n        });\r\n    };\r\n    SuperTabs.prototype.updateTabWidth = function () {\r\n        this.tabsContainer.tabWidth = this.el.nativeElement.offsetWidth;\r\n    };\r\n    SuperTabs.prototype.refreshContainerHeight = function () {\r\n        var heightOffset = 0;\r\n        if (this._isToolbarVisible) {\r\n            if (this.hasTitles && this.hasIcons) {\r\n                heightOffset = 72;\r\n            }\r\n            else if (this.hasTitles || this.hasIcons) {\r\n                heightOffset = 48;\r\n            }\r\n        }\r\n        this.rnd.setStyle(this.tabsContainer.getNativeElement(), 'height', \"calc(100% - \" + heightOffset + \"px)\");\r\n    };\r\n    SuperTabs.prototype.refreshTabWidths = function () {\r\n        var width = this.el.nativeElement.offsetWidth;\r\n        this._tabs.forEach(function (tab) {\r\n            tab.setWidth(width);\r\n        });\r\n    };\r\n    SuperTabs.prototype.alignTabButtonsContainer = function (animate) {\r\n        var mw = this.el.nativeElement.offsetWidth, // max width\r\n        iw = this.toolbar.indicatorWidth, // indicator width\r\n        ip = this.toolbar.indicatorPosition, // indicatorPosition\r\n        sp = this.toolbar.segmentPosition; // segment position\r\n        if (this.toolbar.segmentWidth <= mw) {\r\n            if (this.toolbar.segmentPosition !== 0) {\r\n                this.toolbar.setSegmentPosition(0, animate);\r\n            }\r\n            return;\r\n        }\r\n        var pos;\r\n        if (ip + iw + (mw / 2 - iw / 2) > mw + sp) {\r\n            // we need to move the segment container to the left\r\n            var delta = (ip + iw + (mw / 2 - iw / 2)) - mw - sp;\r\n            pos = sp + delta;\r\n            var max = this.toolbar.segmentWidth - mw;\r\n            pos = pos < max ? pos : max;\r\n        }\r\n        else if (ip - (mw / 2 - iw / 2) < sp) {\r\n            // we need to move the segment container to the right\r\n            pos = ip - (mw / 2 - iw / 2);\r\n            pos = pos >= 0 ? pos : 0;\r\n        }\r\n        else\r\n            return; // no need to move the segment container\r\n        this.toolbar.setSegmentPosition(pos, animate);\r\n    };\r\n    SuperTabs.prototype.getRelativeIndicatorPosition = function (index) {\r\n        if (index === void 0) { index = this.selectedTabIndex; }\r\n        var position = 0;\r\n        for (var i = 0; i < this.toolbar.segmentButtonWidths.length; i++) {\r\n            if (index > Number(i)) {\r\n                position += this.toolbar.segmentButtonWidths[i];\r\n            }\r\n        }\r\n        return position;\r\n    };\r\n    SuperTabs.prototype.getAbsoluteIndicatorPosition = function () {\r\n        var position = this.selectedTabIndex * this.tabsContainer.tabWidth / this._tabs.length;\r\n        return position <= this.maxIndicatorPosition ? position : this.maxIndicatorPosition;\r\n    };\r\n    /**\r\n     * Gets the width of a tab button when `scrollTabs` is set to `true`\r\n     */\r\n    SuperTabs.prototype.getSegmentButtonWidth = function (index) {\r\n        if (index === void 0) { index = this.selectedTabIndex; }\r\n        if (!this._isToolbarVisible)\r\n            return;\r\n        return this.toolbar.segmentButtonWidths[index];\r\n    };\r\n    SuperTabs.prototype.setMaxIndicatorPosition = function () {\r\n        if (this.el && this.el.nativeElement) {\r\n            this.maxIndicatorPosition = this.el.nativeElement.offsetWidth - (this.el.nativeElement.offsetWidth / this._tabs.length);\r\n        }\r\n    };\r\n    SuperTabs.prototype.setFixedIndicatorWidth = function () {\r\n        if (this.scrollTabs || !this._isToolbarVisible)\r\n            return;\r\n        // the width of the \"slide\", should be equal to the width of a single `ion-segment-button`\r\n        // we'll just calculate it instead of querying for a segment button\r\n        this.toolbar.setIndicatorWidth(this.el.nativeElement.offsetWidth / this._tabs.length, false);\r\n    };\r\n    /**\r\n     * Aligns slide position with selected tab\r\n     */\r\n    SuperTabs.prototype.alignIndicatorPosition = function (animate) {\r\n        if (animate === void 0) { animate = false; }\r\n        if (!this._isToolbarVisible)\r\n            return;\r\n        if (this.scrollTabs) {\r\n            this.toolbar.alignIndicator(this.getRelativeIndicatorPosition(), this.getSegmentButtonWidth(), animate);\r\n            this.alignTabButtonsContainer(animate);\r\n        }\r\n        else {\r\n            this.toolbar.setIndicatorPosition(this.getAbsoluteIndicatorPosition(), animate);\r\n        }\r\n    };\r\n    SuperTabs.prototype.getTabIndexById = function (tabId) {\r\n        return this._tabs.findIndex(function (tab) { return tab.tabId === tabId; });\r\n    };\r\n    SuperTabs.prototype.getTabById = function (tabId) {\r\n        return this._tabs.find(function (tab) { return tab.tabId === tabId; });\r\n    };\r\n    SuperTabs.prototype.getActiveTab = function () {\r\n        return this._tabs[this.selectedTabIndex];\r\n    };\r\n    // needed since we're implementing RootNode\r\n    SuperTabs.prototype.getElementRef = function () { return this.el; };\r\n    // needed since we're implementing RootNode\r\n    SuperTabs.prototype.initPane = function () { return true; };\r\n    // needed since we're implementing RootNode\r\n    SuperTabs.prototype.paneChanged = function () { };\r\n    // needed to make Ionic Framework think this is a tabs component... needed for Deeplinking\r\n    SuperTabs.prototype.getSelected = function () { };\r\n    // needed to make Ionic Framework think this is a tabs component... needed for Deeplinking\r\n    SuperTabs.prototype.setTabbarPosition = function () { };\r\n    return SuperTabs;\r\n}());\r\nexport { SuperTabs };\r\nSuperTabs.decorators = [\r\n    { type: Component, args: [{\r\n                selector: 'super-tabs',\r\n                template: \"\\n    <super-tabs-toolbar [tabsPlacement]=\\\"tabsPlacement\\\" [hidden]=\\\"!_isToolbarVisible\\\" [config]=\\\"config\\\"\\n                        [color]=\\\"toolbarBackground\\\"\\n                        [tabsColor]=\\\"toolbarColor\\\" [indicatorColor]=\\\"indicatorColor\\\" [badgeColor]=\\\"badgeColor\\\"\\n                        [scrollTabs]=\\\"scrollTabs\\\"\\n                        [selectedTab]=\\\"selectedTabIndex\\\"\\n                        (tabSelect)=\\\"onToolbarTabSelect($event)\\\"></super-tabs-toolbar>\\n    <super-tabs-container [config]=\\\"config\\\" [tabsCount]=\\\"_tabs.length\\\" [selectedTabIndex]=\\\"selectedTabIndex\\\"\\n                          (tabSelect)=\\\"onContainerTabSelect($event)\\\" (onDrag)=\\\"onDrag($event)\\\">\\n      <ng-content></ng-content>\\n    </super-tabs-container>\\n  \",\r\n                encapsulation: ViewEncapsulation.None,\r\n                providers: [\r\n                    {\r\n                        provide: RootNode,\r\n                        useExisting: forwardRef(function () { return SuperTabs; })\r\n                    }\r\n                ]\r\n            },] },\r\n];\r\n/** @nocollapse */\r\nSuperTabs.ctorParameters = function () { return [\r\n    { type: NavController, decorators: [{ type: Optional },] },\r\n    { type: ViewController, decorators: [{ type: Optional },] },\r\n    { type: App, },\r\n    { type: ElementRef, },\r\n    { type: Renderer2, },\r\n    { type: SuperTabsController, },\r\n    { type: DeepLinker, },\r\n    { type: DomController, },\r\n]; };\r\nSuperTabs.propDecorators = {\r\n    'toolbarBackground': [{ type: Input },],\r\n    'toolbarColor': [{ type: Input },],\r\n    'indicatorColor': [{ type: Input },],\r\n    'badgeColor': [{ type: Input },],\r\n    'config': [{ type: Input },],\r\n    'id': [{ type: Input },],\r\n    'height': [{ type: Input },],\r\n    'selectedTabIndex': [{ type: Input },],\r\n    'scrollTabs': [{ type: Input },],\r\n    'tabsPlacement': [{ type: Input },],\r\n    'tabSelect': [{ type: Output },],\r\n    'toolbar': [{ type: ViewChild, args: [SuperTabsToolbar,] },],\r\n    'tabsContainer': [{ type: ViewChild, args: [SuperTabsContainer,] },],\r\n};\r\nvar superTabsIds = -1;\r\n//# sourceMappingURL=super-tabs.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ionic2-super-tabs/dist/components/super-tabs.js\n// module id = 319\n// module chunks = 0 1 2 3","import { Injectable } from '@angular/core';\r\nvar SuperTabsController = (function () {\r\n    function SuperTabsController() {\r\n        this.instances = [];\r\n    }\r\n    SuperTabsController.prototype.setBadge = function (tabId, value, tabsId) {\r\n        var instance = this.getInstance(tabsId);\r\n        instance && instance.setBadge(tabId, value);\r\n    };\r\n    SuperTabsController.prototype.clearBadge = function (tabId, tabsId) {\r\n        var instance = this.getInstance(tabsId);\r\n        instance && instance.clearBadge(tabId);\r\n    };\r\n    SuperTabsController.prototype.increaseBadge = function (tabId, increaseBy, tabsId) {\r\n        if (increaseBy === void 0) { increaseBy = 1; }\r\n        var instance = this.getInstance(tabsId);\r\n        instance && instance.increaseBadge(tabId, increaseBy);\r\n    };\r\n    SuperTabsController.prototype.decreaseBadge = function (tabId, decreaseBy, tabsId) {\r\n        if (decreaseBy === void 0) { decreaseBy = 1; }\r\n        var instance = this.getInstance(tabsId);\r\n        instance && instance.decreaseBadge(tabId, decreaseBy);\r\n    };\r\n    /**\r\n     * Enables/disables swiping on a specific tabs instance\r\n     * @param enable\r\n     * @param [tabsId]\r\n     */\r\n    SuperTabsController.prototype.enableTabsSwipe = function (enable, tabsId) {\r\n        var instance = this.getInstance(tabsId);\r\n        instance && instance.enableTabsSwipe(enable);\r\n    };\r\n    /**\r\n     * Enables/disables swiping when this tab is active\r\n     * @param tabId\r\n     * @param enable\r\n     * @param [tabsId]\r\n     */\r\n    SuperTabsController.prototype.enableTabSwipe = function (tabId, enable, tabsId) {\r\n        var instance = this.getInstance(tabsId);\r\n        instance && instance.enableTabSwipe(tabId, enable);\r\n    };\r\n    SuperTabsController.prototype.showToolbar = function (show, tabsId) {\r\n        var instance = this.getInstance(tabsId);\r\n        instance && instance.showToolbar(show);\r\n    };\r\n    SuperTabsController.prototype.slideTo = function (tabIndexOrId, tabsId) {\r\n        var instance = this.getInstance(tabsId);\r\n        instance && instance.slideTo(tabIndexOrId);\r\n    };\r\n    /**\r\n     * @private\r\n     */\r\n    SuperTabsController.prototype.registerInstance = function (instance) {\r\n        this.instances.push(instance);\r\n    };\r\n    /**\r\n     * @private\r\n     */\r\n    SuperTabsController.prototype.unregisterInstance = function (id) {\r\n        var instanceIndex = this.getInstanceIndex(id);\r\n        if (instanceIndex > -1)\r\n            this.instances.splice(instanceIndex, 1);\r\n    };\r\n    SuperTabsController.prototype.getInstanceIndex = function (id) {\r\n        return this.instances.findIndex(function (instance) { return instance.id === id; });\r\n    };\r\n    SuperTabsController.prototype.getInstance = function (id) {\r\n        return (!!id && this.instances[this.getInstanceIndex(id)]) || this.instances[0];\r\n    };\r\n    return SuperTabsController;\r\n}());\r\nexport { SuperTabsController };\r\nSuperTabsController.decorators = [\r\n    { type: Injectable },\r\n];\r\n/** @nocollapse */\r\nSuperTabsController.ctorParameters = function () { return []; };\r\n//# sourceMappingURL=super-tabs-controller.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ionic2-super-tabs/dist/providers/super-tabs-controller.js\n// module id = 320\n// module chunks = 0 1 2 3","import { Component, Input, Output, EventEmitter, ChangeDetectionStrategy, ViewEncapsulation, ElementRef } from '@angular/core';\r\nvar SuperTabButton = (function () {\r\n    function SuperTabButton(_el) {\r\n        this._el = _el;\r\n        this.selected = false;\r\n        this.select = new EventEmitter();\r\n    }\r\n    SuperTabButton.prototype.onClick = function () {\r\n        this.select.emit(this);\r\n    };\r\n    SuperTabButton.prototype.getNativeElement = function () {\r\n        return this._el.nativeElement;\r\n    };\r\n    return SuperTabButton;\r\n}());\r\nexport { SuperTabButton };\r\nSuperTabButton.decorators = [\r\n    { type: Component, args: [{\r\n                selector: 'super-tab-button',\r\n                template: \"\\n    <ion-icon *ngIf=\\\"!!icon\\\" [name]=\\\"icon\\\" [color]=\\\"color\\\"></ion-icon>\\n    <span class=\\\"title\\\" *ngIf=\\\"!!title\\\" ion-text [color]=\\\"color\\\">{{ title }}</span>\\n    <ion-badge mode=\\\"md\\\" [color]=\\\"badgeColor\\\">{{ badge }}</ion-badge>\\n    <!--<span class=\\\"badge badge-md {{ 'badge-md-' + badgeColor }}\\\">{{ badge }}</span>-->\\n    <div class=\\\"button-effect\\\"></div>\\n  \",\r\n                host: {\r\n                    '[class.selected]': 'selected',\r\n                    '(click)': 'onClick()',\r\n                    '[class.title-only]': '!!title && !icon',\r\n                    '[class.icon-only]': '!title && !!icon',\r\n                    '[class.title-and-icon]': '!!title && !!icon',\r\n                    'tappable': '',\r\n                    'role': 'button'\r\n                },\r\n                changeDetection: ChangeDetectionStrategy.OnPush,\r\n                encapsulation: ViewEncapsulation.None\r\n            },] },\r\n];\r\n/** @nocollapse */\r\nSuperTabButton.ctorParameters = function () { return [\r\n    { type: ElementRef, },\r\n]; };\r\nSuperTabButton.propDecorators = {\r\n    'selected': [{ type: Input },],\r\n    'title': [{ type: Input },],\r\n    'icon': [{ type: Input },],\r\n    'badge': [{ type: Input },],\r\n    'badgeColor': [{ type: Input },],\r\n    'color': [{ type: Input },],\r\n    'select': [{ type: Output },],\r\n};\r\n//# sourceMappingURL=super-tab-button.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ionic2-super-tabs/dist/components/super-tab-button.js\n// module id = 322\n// module chunks = 0 1 2 3","var __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nimport { Component, Input, Renderer, ElementRef, ViewEncapsulation, Optional, ComponentFactoryResolver, NgZone, ViewContainerRef, ViewChild, ChangeDetectorRef, ErrorHandler } from '@angular/core';\r\nimport { NavControllerBase, App, Config, Platform, GestureController, DeepLinker, DomController } from 'ionic-angular';\r\nimport { TransitionController } from 'ionic-angular/transitions/transition-controller';\r\nimport { SuperTabs } from './super-tabs';\r\nvar SuperTab = (function (_super) {\r\n    __extends(SuperTab, _super);\r\n    function SuperTab(parent, app, config, plt, el, zone, rnd, cfr, gestureCtrl, transCtrl, errorHandler, linker, _dom, cd) {\r\n        var _this = _super.call(this, parent, app, config, plt, el, zone, rnd, cfr, gestureCtrl, transCtrl, linker, _dom, errorHandler) || this;\r\n        _this.linker = linker;\r\n        _this._dom = _dom;\r\n        _this.cd = cd;\r\n        /**\r\n         * Indicates whether the tab has been loaded\r\n         * @type {boolean}\r\n         */\r\n        _this.loaded = false;\r\n        _this.init = new Promise(function (resolve) { return _this.initResolve = resolve; });\r\n        return _this;\r\n    }\r\n    Object.defineProperty(SuperTab.prototype, \"tabTitle\", {\r\n        // TODO find less hacky approach\r\n        // needed to make Ionic Framework think this is a tabs component... needed for Deeplinking\r\n        get: function () {\r\n            return this.title;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(SuperTab.prototype, \"index\", {\r\n        // needed to make Ionic Framework think this is a tabs component... needed for Deeplinking\r\n        get: function () {\r\n            return this.parent.getTabIndexById(this.tabId);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(SuperTab.prototype, \"_tabId\", {\r\n        get: function () {\r\n            return this.tabId;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(SuperTab.prototype, \"swipeBackEnabled\", {\r\n        /**\r\n         * Enable/disable swipe to go back for iOS\r\n         * @return {boolean}\r\n         */\r\n        get: function () {\r\n            return this._sbEnabled;\r\n        },\r\n        set: function (val) {\r\n            this._sbEnabled = !!val;\r\n            this._swipeBackCheck();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(SuperTab.prototype, \"_vp\", {\r\n        /**\r\n         * @hidden\r\n         */\r\n        set: function (val) {\r\n            this.setViewport(val);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    SuperTab.prototype.ngOnInit = function () {\r\n        this.parent.addTab(this);\r\n    };\r\n    SuperTab.prototype.ngAfterViewInit = function () {\r\n        this.initResolve();\r\n    };\r\n    SuperTab.prototype.ngOnDestroy = function () {\r\n        this.destroy();\r\n    };\r\n    SuperTab.prototype.setActive = function (active) {\r\n        if (active) {\r\n            this.cd.reattach();\r\n            this.cd.detectChanges();\r\n        }\r\n        else if (!active) {\r\n            this.cd.detach();\r\n        }\r\n    };\r\n    SuperTab.prototype.load = function (load) {\r\n        var _this = this;\r\n        if (load && !this.loaded) {\r\n            this.init.then(function () {\r\n                _this.push(_this.root, _this.rootParams, { animate: false });\r\n                _this.loaded = true;\r\n            });\r\n        }\r\n    };\r\n    SuperTab.prototype.setBadge = function (value) {\r\n        this.badge = value;\r\n    };\r\n    SuperTab.prototype.clearBadge = function () {\r\n        delete this.badge;\r\n    };\r\n    SuperTab.prototype.increaseBadge = function (increaseBy) {\r\n        if (increaseBy === void 0) { increaseBy = 1; }\r\n        this.badge += increaseBy;\r\n    };\r\n    SuperTab.prototype.decreaseBadge = function (decreaseBy) {\r\n        if (decreaseBy === void 0) { decreaseBy = 1; }\r\n        this.badge = Math.max(0, this.badge - decreaseBy);\r\n    };\r\n    SuperTab.prototype.setWidth = function (width) {\r\n        this.setElementStyle('width', width + 'px');\r\n    };\r\n    return SuperTab;\r\n}(NavControllerBase));\r\nexport { SuperTab };\r\nSuperTab.decorators = [\r\n    { type: Component, args: [{\r\n                selector: 'super-tab',\r\n                template: '<div #viewport></div><div class=\"nav-decor\"></div>',\r\n                encapsulation: ViewEncapsulation.None\r\n            },] },\r\n];\r\n/** @nocollapse */\r\nSuperTab.ctorParameters = function () { return [\r\n    { type: SuperTabs, },\r\n    { type: App, },\r\n    { type: Config, },\r\n    { type: Platform, },\r\n    { type: ElementRef, },\r\n    { type: NgZone, },\r\n    { type: Renderer, },\r\n    { type: ComponentFactoryResolver, },\r\n    { type: GestureController, },\r\n    { type: TransitionController, },\r\n    { type: ErrorHandler, },\r\n    { type: DeepLinker, decorators: [{ type: Optional },] },\r\n    { type: DomController, },\r\n    { type: ChangeDetectorRef, },\r\n]; };\r\nSuperTab.propDecorators = {\r\n    'title': [{ type: Input },],\r\n    'icon': [{ type: Input },],\r\n    'root': [{ type: Input },],\r\n    'rootParams': [{ type: Input },],\r\n    'tabId': [{ type: Input, args: ['id',] },],\r\n    'badge': [{ type: Input },],\r\n    'swipeBackEnabled': [{ type: Input },],\r\n    '_vp': [{ type: ViewChild, args: ['viewport', { read: ViewContainerRef },] },],\r\n};\r\n//# sourceMappingURL=super-tab.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ionic2-super-tabs/dist/components/super-tab.js\n// module id = 323\n// module chunks = 0 1 2 3","import { Component, Renderer2, ElementRef, Input, Output, EventEmitter, ViewChild, ViewEncapsulation, NgZone } from '@angular/core';\r\nimport { Platform } from 'ionic-angular';\r\nimport { SuperTabsPanGesture } from '../super-tabs-pan-gesture';\r\nvar SuperTabsContainer = (function () {\r\n    function SuperTabsContainer(el, rnd, plt, ngZone) {\r\n        this.el = el;\r\n        this.rnd = rnd;\r\n        this.plt = plt;\r\n        this.ngZone = ngZone;\r\n        /**\r\n         * Number of tabs\r\n         * @type {number}\r\n         */\r\n        this.tabsCount = 0;\r\n        /**\r\n         * Notifies when a tab is selected\r\n         * @type {EventEmitter<Object>}\r\n         */\r\n        this.tabSelect = new EventEmitter();\r\n        /**\r\n         * Notifies when the container is being dragged\r\n         * @type {EventEmitter<TouchEvent>}\r\n         */\r\n        this.onDrag = new EventEmitter();\r\n        // View bindings\r\n        /**\r\n         * Container position\r\n         * @type {number}\r\n         */\r\n        this.containerPosition = 0;\r\n        /**\r\n         * Single tab width\r\n         * @type {number}\r\n         */\r\n        this.tabWidth = 0;\r\n        /**\r\n         * Container width (sum of tab widths)\r\n         * @type {number}\r\n         */\r\n        this.containerWidth = 0;\r\n        this.globalSwipeEnabled = true;\r\n        this.swipeEnabledPerTab = {};\r\n    }\r\n    SuperTabsContainer.prototype.ngAfterViewInit = function () {\r\n        this.init();\r\n    };\r\n    SuperTabsContainer.prototype.ngOnDestroy = function () {\r\n        this.gesture && this.gesture.destroy();\r\n    };\r\n    SuperTabsContainer.prototype.enableTabsSwipe = function (enable) {\r\n        this.globalSwipeEnabled = enable;\r\n    };\r\n    SuperTabsContainer.prototype.enableTabSwipe = function (tabIndex, enable) {\r\n        this.swipeEnabledPerTab[tabIndex] = enable;\r\n    };\r\n    SuperTabsContainer.prototype.refreshDimensions = function () {\r\n        this.calculateContainerWidth();\r\n        this.setContainerWidth();\r\n        this.refreshMinMax();\r\n    };\r\n    SuperTabsContainer.prototype.getNativeElement = function () {\r\n        return this.el.nativeElement;\r\n    };\r\n    SuperTabsContainer.prototype.init = function () {\r\n        var _this = this;\r\n        this.refreshDimensions();\r\n        this.gesture = new SuperTabsPanGesture(this.plt, this.container.nativeElement, this.config, this.rnd);\r\n        this.gesture.onMove = function (delta) {\r\n            if (_this.globalSwipeEnabled === false)\r\n                return;\r\n            if (_this.swipeEnabledPerTab[_this.selectedTabIndex] === false)\r\n                return;\r\n            if ((_this.containerPosition === _this.maxPosX && delta >= 0) || (_this.containerPosition === _this.minPosX && delta <= 0))\r\n                return;\r\n            _this.containerPosition += delta;\r\n            _this.plt.raf(function () {\r\n                _this.onDrag.emit();\r\n                _this.moveContainer();\r\n            });\r\n        };\r\n        this.gesture.onEnd = function (shortSwipe, shortSwipeDelta) {\r\n            if (_this.globalSwipeEnabled === false)\r\n                return;\r\n            if (_this.swipeEnabledPerTab[_this.selectedTabIndex] === false)\r\n                return;\r\n            // get tab index based on container position\r\n            var tabIndex = Math.round(_this.containerPosition / _this.tabWidth);\r\n            // handle short swipes\r\n            // only short swipe if we didn't change tab already in this gesture\r\n            (tabIndex === _this.selectedTabIndex) && shortSwipe && ((shortSwipeDelta < 0 && tabIndex++) || (shortSwipeDelta > 0 && tabIndex--));\r\n            // get location based on tab index\r\n            var position = Math.max(_this.minPosX, Math.min(_this.maxPosX, tabIndex * _this.tabWidth));\r\n            tabIndex = position / _this.tabWidth;\r\n            // move container if we changed position\r\n            if (position !== _this.containerPosition) {\r\n                _this.plt.raf(function () {\r\n                    _this.moveContainer(true, position, function () { return _this.ngZone.run(function () { return _this.setSelectedTab(tabIndex); }); });\r\n                });\r\n            }\r\n            else\r\n                _this.setSelectedTab(tabIndex);\r\n        };\r\n    };\r\n    SuperTabsContainer.prototype.setSelectedTab = function (index) {\r\n        this.tabSelect.emit({ index: index, changed: index !== this.selectedTabIndex });\r\n        this.selectedTabIndex = index;\r\n    };\r\n    SuperTabsContainer.prototype.calculateContainerWidth = function () {\r\n        this.containerWidth = this.tabWidth * this.tabsCount;\r\n    };\r\n    SuperTabsContainer.prototype.setContainerWidth = function () {\r\n        this.rnd.setStyle(this.container.nativeElement, 'width', this.containerWidth + 'px');\r\n    };\r\n    SuperTabsContainer.prototype.slideTo = function (index, animate) {\r\n        var _this = this;\r\n        if (animate === void 0) { animate = true; }\r\n        this.plt.raf(function () { return _this.moveContainer(animate, index * _this.tabWidth); });\r\n    };\r\n    SuperTabsContainer.prototype.moveContainer = function (animate, positionX, callback) {\r\n        if (animate === void 0) { animate = false; }\r\n        if (callback === void 0) { callback = function () { }; }\r\n        var el = this.container.nativeElement;\r\n        if (animate) {\r\n            if (el.style[this.plt.Css.transform].indexOf('all') === -1) {\r\n                this.rnd.setStyle(el, this.plt.Css.transition, \"all \" + this.config.transitionDuration + \"ms \" + this.config.transitionEase);\r\n            }\r\n            this.rnd.setStyle(el, this.plt.Css.transform, \"translate3d(\" + -1 * positionX + \"px, 0, 0)\");\r\n            this.containerPosition = positionX;\r\n        }\r\n        else {\r\n            if (positionX) {\r\n                this.containerPosition = positionX;\r\n            }\r\n            if (el.style[this.plt.Css.transform] !== 'initial') {\r\n                this.rnd.setStyle(el, this.plt.Css.transition, 'initial');\r\n            }\r\n            this.containerPosition = Math.max(this.minPosX, Math.min(this.maxPosX, this.containerPosition));\r\n            this.rnd.setStyle(el, this.plt.Css.transform, \"translate3d(\" + -1 * this.containerPosition + \"px, 0, 0)\");\r\n        }\r\n        callback();\r\n    };\r\n    SuperTabsContainer.prototype.refreshMinMax = function () {\r\n        this.minPosX = 0;\r\n        this.maxPosX = (this.tabsCount - 1) * this.tabWidth;\r\n    };\r\n    return SuperTabsContainer;\r\n}());\r\nexport { SuperTabsContainer };\r\nSuperTabsContainer.decorators = [\r\n    { type: Component, args: [{\r\n                selector: 'super-tabs-container',\r\n                template: '<div #container><ng-content></ng-content></div>',\r\n                encapsulation: ViewEncapsulation.None\r\n            },] },\r\n];\r\n/** @nocollapse */\r\nSuperTabsContainer.ctorParameters = function () { return [\r\n    { type: ElementRef, },\r\n    { type: Renderer2, },\r\n    { type: Platform, },\r\n    { type: NgZone, },\r\n]; };\r\nSuperTabsContainer.propDecorators = {\r\n    'config': [{ type: Input },],\r\n    'tabsCount': [{ type: Input },],\r\n    'selectedTabIndex': [{ type: Input },],\r\n    'tabSelect': [{ type: Output },],\r\n    'onDrag': [{ type: Output },],\r\n    'container': [{ type: ViewChild, args: ['container',] },],\r\n};\r\n//# sourceMappingURL=super-tabs-container.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ionic2-super-tabs/dist/components/super-tabs-container.js\n// module id = 324\n// module chunks = 0 1 2 3","import { Component, Input, Output, EventEmitter, ElementRef, ViewChildren, ViewEncapsulation, ViewChild, Renderer2 } from '@angular/core';\r\nimport { Platform, DomController } from 'ionic-angular';\r\nimport { SuperTabsPanGesture } from '../super-tabs-pan-gesture';\r\nimport { SuperTabButton } from \"./super-tab-button\";\r\nvar SuperTabsToolbar = (function () {\r\n    function SuperTabsToolbar(el, plt, rnd, domCtrl) {\r\n        this.el = el;\r\n        this.plt = plt;\r\n        this.rnd = rnd;\r\n        this.domCtrl = domCtrl;\r\n        this.color = '';\r\n        this.tabsColor = '';\r\n        this.badgeColor = '';\r\n        this.scrollTabs = false;\r\n        this.indicatorColor = '';\r\n        this.selectedTab = 0;\r\n        this.indicatorPosition = 0;\r\n        this.indicatorWidth = 0;\r\n        this.tabSelect = new EventEmitter();\r\n        /**\r\n         * @private\r\n         */\r\n        this.segmentPosition = 0;\r\n        /**\r\n         * The width of each button\r\n         */\r\n        this.segmentButtonWidths = [];\r\n        /**\r\n         * The segment width\r\n         */\r\n        this.segmentWidth = 0;\r\n        this.tabs = [];\r\n        this.animationState = {\r\n            indicator: false,\r\n            segment: false\r\n        };\r\n    }\r\n    SuperTabsToolbar.prototype.ngAfterViewInit = function () {\r\n        var _this = this;\r\n        this.gesture = new SuperTabsPanGesture(this.plt, this.tabButtonsContainer.nativeElement, this.config, this.rnd);\r\n        this.gesture.onMove = function (delta) {\r\n            var newCPos = _this.segmentPosition + delta;\r\n            var mw = _this.el.nativeElement.offsetWidth, cw = _this.segmentWidth;\r\n            newCPos = Math.max(0, Math.min(newCPos, cw - mw));\r\n            _this.setSegmentPosition(newCPos);\r\n        };\r\n        if (this.scrollTabs) {\r\n            this.plt.timeout(function () {\r\n                _this.indexSegmentButtonWidths();\r\n            }, 10);\r\n        }\r\n    };\r\n    SuperTabsToolbar.prototype.ngOnDestroy = function () {\r\n        this.gesture && this.gesture.destroy();\r\n    };\r\n    SuperTabsToolbar.prototype.onTabSelect = function (index) {\r\n        this.tabSelect.emit(index);\r\n    };\r\n    SuperTabsToolbar.prototype.alignIndicator = function (position, width, animate) {\r\n        this.setIndicatorProperties(width, position, animate);\r\n    };\r\n    SuperTabsToolbar.prototype.setIndicatorPosition = function (position, animate) {\r\n        this.setIndicatorProperties(this.indicatorWidth, position, animate);\r\n    };\r\n    SuperTabsToolbar.prototype.setIndicatorWidth = function (width, animate) {\r\n        this.setIndicatorProperties(width, this.indicatorPosition, animate);\r\n    };\r\n    SuperTabsToolbar.prototype.setIndicatorProperties = function (width, position, animate) {\r\n        this.indicatorWidth = width;\r\n        this.indicatorPosition = position;\r\n        var scale = width / 100;\r\n        this.toggleAnimation('indicator', animate);\r\n        this.rnd.setStyle(this.indicator.nativeElement, this.plt.Css.transform, 'translate3d(' + (position - this.segmentPosition) + 'px, 0, 0) scale3d(' + scale + ', 1, 1)');\r\n    };\r\n    SuperTabsToolbar.prototype.setSegmentPosition = function (position, animate) {\r\n        this.segmentPosition = position;\r\n        this.toggleAnimation('segment', animate);\r\n        this.rnd.setStyle(this.tabButtonsBar.nativeElement, this.plt.Css.transform, \"translate3d(\" + -1 * position + \"px,0,0)\");\r\n        this.setIndicatorPosition(this.indicatorPosition, animate);\r\n    };\r\n    /**\r\n     * Enables/disables animation\r\n     * @param el\r\n     * @param animate\r\n     */\r\n    SuperTabsToolbar.prototype.toggleAnimation = function (el, animate) {\r\n        if (!this.config || this.config.transitionDuration === 0)\r\n            return;\r\n        // only change style if the value changed\r\n        if (this.animationState[el] === animate)\r\n            return;\r\n        this.animationState[el] = animate;\r\n        var _el = el === 'indicator' ? this.indicator.nativeElement : this.tabButtonsBar.nativeElement;\r\n        var value = animate ? \"all \" + this.config.transitionDuration + \"ms \" + this.config.transitionEase : 'initial';\r\n        this.rnd.setStyle(_el, this.plt.Css.transition, value);\r\n    };\r\n    /**\r\n     * Indexes the segment button widths\r\n     */\r\n    SuperTabsToolbar.prototype.indexSegmentButtonWidths = function () {\r\n        var index = [], total = 0;\r\n        this.tabButtons.forEach(function (btn, i) {\r\n            index[i] = btn.getNativeElement().offsetWidth;\r\n            total += index[i];\r\n        });\r\n        this.segmentButtonWidths = index;\r\n        this.segmentWidth = total;\r\n    };\r\n    return SuperTabsToolbar;\r\n}());\r\nexport { SuperTabsToolbar };\r\nSuperTabsToolbar.decorators = [\r\n    { type: Component, args: [{\r\n                selector: 'super-tabs-toolbar',\r\n                template: \"\\n    <ion-toolbar [color]=\\\"color\\\" mode=\\\"md\\\" [class.scroll-tabs]=\\\"scrollTabs\\\">\\n      <div class=\\\"tab-buttons-container\\\" #tabButtonsContainer>\\n        <div *ngIf=\\\"tabsPlacement === 'bottom'\\\" class=\\\"indicator {{ 'button-md-' + indicatorColor }}\\\" #indicator></div>\\n        <div class=\\\"tab-buttons\\\" #tabButtons>\\n          <super-tab-button *ngFor=\\\"let tab of tabs; let i = index\\\" (select)=\\\"selectedTab !== i && onTabSelect(i)\\\" [title]=\\\"tab.title\\\" [icon]=\\\"tab.icon\\\" [badge]=\\\"tab.badge\\\" [selected]=\\\"selectedTab === i\\\" [color]=\\\"tabsColor\\\" [badgeColor]=\\\"badgeColor\\\"></super-tab-button>\\n        </div>\\n        <div *ngIf=\\\"tabsPlacement === 'top'\\\" class=\\\"indicator {{ 'button-md-' + indicatorColor }}\\\" #indicator></div>\\n      </div>\\n    </ion-toolbar>\\n  \",\r\n                encapsulation: ViewEncapsulation.None\r\n            },] },\r\n];\r\n/** @nocollapse */\r\nSuperTabsToolbar.ctorParameters = function () { return [\r\n    { type: ElementRef, },\r\n    { type: Platform, },\r\n    { type: Renderer2, },\r\n    { type: DomController, },\r\n]; };\r\nSuperTabsToolbar.propDecorators = {\r\n    'color': [{ type: Input },],\r\n    'tabsColor': [{ type: Input },],\r\n    'badgeColor': [{ type: Input },],\r\n    'scrollTabs': [{ type: Input },],\r\n    'indicatorColor': [{ type: Input },],\r\n    'selectedTab': [{ type: Input },],\r\n    'config': [{ type: Input },],\r\n    'tabsPlacement': [{ type: Input },],\r\n    'tabSelect': [{ type: Output },],\r\n    'tabButtons': [{ type: ViewChildren, args: [SuperTabButton,] },],\r\n    'tabButtonsContainer': [{ type: ViewChild, args: ['tabButtonsContainer',] },],\r\n    'indicator': [{ type: ViewChild, args: ['indicator',] },],\r\n    'tabButtonsBar': [{ type: ViewChild, args: ['tabButtons',] },],\r\n};\r\n//# sourceMappingURL=super-tabs-toolbar.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ionic2-super-tabs/dist/components/super-tabs-toolbar.js\n// module id = 325\n// module chunks = 0 1 2 3","import { pointerCoord } from 'ionic-angular/util/dom';\r\nvar SuperTabsPanGesture = (function () {\r\n    function SuperTabsPanGesture(plt, el, config, rnd) {\r\n        this.plt = plt;\r\n        this.el = el;\r\n        this.config = config;\r\n        this.rnd = rnd;\r\n        this.leftThreshold = 0;\r\n        this.rightThreshold = 0;\r\n        this.listeners = [];\r\n        this.listeners.push(rnd.listen(el, 'touchstart', this._onStart.bind(this)), rnd.listen(el, 'touchmove', this._onMove.bind(this)), rnd.listen(el, 'touchend', this._onEnd.bind(this)));\r\n        if (config.sideMenu === 'both' || config.sideMenu === 'left') {\r\n            this.leftThreshold = config.sideMenuThreshold;\r\n        }\r\n        if (config.sideMenu === 'both' || config.sideMenu === 'right') {\r\n            this.rightThreshold = config.sideMenuThreshold;\r\n        }\r\n    }\r\n    SuperTabsPanGesture.prototype.destroy = function () {\r\n        this.listeners.forEach(function (fn) { return fn(); });\r\n    };\r\n    SuperTabsPanGesture.prototype._onStart = function (ev) {\r\n        var coords = pointerCoord(ev), vw = this.plt.width();\r\n        if (coords.x < this.leftThreshold || coords.x > vw - this.rightThreshold) {\r\n            // ignore this gesture, it started in the side menu touch zone\r\n            this.shouldCapture = false;\r\n            return;\r\n        }\r\n        // the starting point looks good, let's see what happens when we move\r\n        this.initialCoords = coords;\r\n        if (this.config.shortSwipeDuration > 0)\r\n            this.initialTimestamp = Date.now();\r\n        this.lastPosX = coords.x;\r\n    };\r\n    SuperTabsPanGesture.prototype._onMove = function (ev) {\r\n        var coords = pointerCoord(ev);\r\n        if (!this.isDragging) {\r\n            if (typeof this.shouldCapture !== 'boolean')\r\n                // we haven't decided yet if we want to capture this gesture\r\n                this.checkGesture(coords);\r\n            if (this.shouldCapture === true)\r\n                // gesture is good, let's capture all next onTouchMove events\r\n                this.isDragging = true;\r\n            else\r\n                return;\r\n        }\r\n        // stop anything else from capturing these events, to make sure the content doesn't slide\r\n        ev.stopPropagation();\r\n        ev.preventDefault();\r\n        // get delta X\r\n        var deltaX = this.lastPosX - coords.x;\r\n        // emit value\r\n        this.onMove && this.onMove(deltaX);\r\n        // update last X value\r\n        this.lastPosX = coords.x;\r\n    };\r\n    SuperTabsPanGesture.prototype._onEnd = function (ev) {\r\n        var coords = pointerCoord(ev);\r\n        if (this.shouldCapture === true) {\r\n            if (this.config.shortSwipeDuration > 0) {\r\n                var deltaTime = Date.now() - this.initialTimestamp;\r\n                if (deltaTime <= this.config.shortSwipeDuration)\r\n                    this.onEnd && this.onEnd(true, coords.x - this.initialCoords.x);\r\n                else\r\n                    this.onEnd && this.onEnd(false);\r\n            }\r\n            else\r\n                this.onEnd && this.onEnd(false);\r\n        }\r\n        this.isDragging = false;\r\n        this.shouldCapture = undefined;\r\n    };\r\n    SuperTabsPanGesture.prototype.checkGesture = function (newCoords) {\r\n        var radians = this.config.maxDragAngle * (Math.PI / 180), maxCosine = Math.cos(radians), deltaX = newCoords.x - this.initialCoords.x, deltaY = newCoords.y - this.initialCoords.y, distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\r\n        if (distance >= this.config.dragThreshold) {\r\n            // swipe is long enough so far\r\n            // lets check the angle\r\n            var angle = Math.atan2(deltaY, deltaX), cosine = Math.cos(angle);\r\n            this.shouldCapture = Math.abs(cosine) > maxCosine;\r\n        }\r\n    };\r\n    return SuperTabsPanGesture;\r\n}());\r\nexport { SuperTabsPanGesture };\r\n//# sourceMappingURL=super-tabs-pan-gesture.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ionic2-super-tabs/dist/super-tabs-pan-gesture.js\n// module id = 326\n// module chunks = 0 1 2 3","export * from './components/super-tab';\r\nexport * from './components/super-tabs';\r\nexport * from './providers/super-tabs-controller';\r\nexport * from './super-tabs.module';\r\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ionic2-super-tabs/dist/index.js\n// module id = 332\n// module chunks = 0 1 2 3","import { NgModule } from '@angular/core';\r\nimport { IonicModule } from 'ionic-angular';\r\nimport { SuperTab } from './components/super-tab';\r\nimport { SuperTabs } from './components/super-tabs';\r\nimport { SuperTabsController } from './providers/super-tabs-controller';\r\nimport { SuperTabsToolbar } from './components/super-tabs-toolbar';\r\nimport { SuperTabsContainer } from './components/super-tabs-container';\r\nimport { SuperTabButton } from './components/super-tab-button';\r\nvar SuperTabsModule = (function () {\r\n    function SuperTabsModule() {\r\n    }\r\n    SuperTabsModule.forRoot = function () {\r\n        return {\r\n            ngModule: SuperTabsModule,\r\n            providers: [\r\n                SuperTabsController\r\n            ]\r\n        };\r\n    };\r\n    return SuperTabsModule;\r\n}());\r\nexport { SuperTabsModule };\r\nSuperTabsModule.decorators = [\r\n    { type: NgModule, args: [{\r\n                declarations: [\r\n                    SuperTab,\r\n                    SuperTabs,\r\n                    SuperTabsToolbar,\r\n                    SuperTabsContainer,\r\n                    SuperTabButton\r\n                ],\r\n                imports: [\r\n                    IonicModule\r\n                ],\r\n                exports: [\r\n                    SuperTab,\r\n                    SuperTabs\r\n                ]\r\n            },] },\r\n];\r\n/** @nocollapse */\r\nSuperTabsModule.ctorParameters = function () { return []; };\r\n//# sourceMappingURL=super-tabs.module.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ionic2-super-tabs/dist/super-tabs.module.js\n// module id = 333\n// module chunks = 0 1 2 3","\"use strict\";\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an {@link Action}.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @class Scheduler\n */\nvar Scheduler = (function () {\n    function Scheduler(SchedulerAction, now) {\n        if (now === void 0) { now = Scheduler.now; }\n        this.SchedulerAction = SchedulerAction;\n        this.now = now;\n    }\n    /**\n     * Schedules a function, `work`, for execution. May happen at some point in\n     * the future, according to the `delay` parameter, if specified. May be passed\n     * some context object, `state`, which will be passed to the `work` function.\n     *\n     * The given arguments will be processed an stored as an Action object in a\n     * queue of actions.\n     *\n     * @param {function(state: ?T): ?Subscription} work A function representing a\n     * task, or some unit of work to be executed by the Scheduler.\n     * @param {number} [delay] Time to wait before executing the work, where the\n     * time unit is implicit and defined by the Scheduler itself.\n     * @param {T} [state] Some contextual data that the `work` function uses when\n     * called by the Scheduler.\n     * @return {Subscription} A subscription in order to be able to unsubscribe\n     * the scheduled work.\n     */\n    Scheduler.prototype.schedule = function (work, delay, state) {\n        if (delay === void 0) { delay = 0; }\n        return new this.SchedulerAction(this, work).schedule(state, delay);\n    };\n    Scheduler.now = Date.now ? Date.now : function () { return +new Date(); };\n    return Scheduler;\n}());\nexports.Scheduler = Scheduler;\n//# sourceMappingURL=Scheduler.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/Scheduler.js\n// module id = 334\n// module chunks = 0 1 2 3","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar merge_1 = require('../../observable/merge');\nObservable_1.Observable.merge = merge_1.merge;\n//# sourceMappingURL=merge.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/observable/merge.js\n// module id = 335\n// module chunks = 0 1 2 3","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar debounceTime_1 = require('../../operator/debounceTime');\nObservable_1.Observable.prototype.debounceTime = debounceTime_1.debounceTime;\n//# sourceMappingURL=debounceTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/debounceTime.js\n// module id = 336\n// module chunks = 0 1 2 3","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar async_1 = require('../scheduler/async');\n/**\n * Emits a value from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent value from each burst of emissions.</span>\n *\n * <img src=\"./img/debounceTime.png\" width=\"100%\">\n *\n * `debounceTime` delays values emitted by the source Observable, but drops\n * previous pending delayed emissions if a new value arrives on the source\n * Observable. This operator keeps track of the most recent value from the\n * source Observable, and emits that only when `dueTime` enough time has passed\n * without any other value appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous value will be dropped\n * and will not be emitted on the output Observable.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * value to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link IScheduler} for\n * managing timers.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounceTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the timeout for each value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified `dueTime`, and may drop some values if they occur\n * too frequently.\n * @method debounceTime\n * @owner Observable\n */\nfunction debounceTime(dueTime, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return this.lift(new DebounceTimeOperator(dueTime, scheduler));\n}\nexports.debounceTime = debounceTime;\nvar DebounceTimeOperator = (function () {\n    function DebounceTimeOperator(dueTime, scheduler) {\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n    }\n    DebounceTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\n    };\n    return DebounceTimeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DebounceTimeSubscriber = (function (_super) {\n    __extends(DebounceTimeSubscriber, _super);\n    function DebounceTimeSubscriber(destination, dueTime, scheduler) {\n        _super.call(this, destination);\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n        this.debouncedSubscription = null;\n        this.lastValue = null;\n        this.hasValue = false;\n    }\n    DebounceTimeSubscriber.prototype._next = function (value) {\n        this.clearDebounce();\n        this.lastValue = value;\n        this.hasValue = true;\n        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\n    };\n    DebounceTimeSubscriber.prototype._complete = function () {\n        this.debouncedNext();\n        this.destination.complete();\n    };\n    DebounceTimeSubscriber.prototype.debouncedNext = function () {\n        this.clearDebounce();\n        if (this.hasValue) {\n            this.destination.next(this.lastValue);\n            this.lastValue = null;\n            this.hasValue = false;\n        }\n    };\n    DebounceTimeSubscriber.prototype.clearDebounce = function () {\n        var debouncedSubscription = this.debouncedSubscription;\n        if (debouncedSubscription !== null) {\n            this.remove(debouncedSubscription);\n            debouncedSubscription.unsubscribe();\n            this.debouncedSubscription = null;\n        }\n    };\n    return DebounceTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchNext(subscriber) {\n    subscriber.debouncedNext();\n}\n//# sourceMappingURL=debounceTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/debounceTime.js\n// module id = 337\n// module chunks = 0 1 2 3","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = require('../Subscription');\n/**\n * A unit of work to be executed in a {@link Scheduler}. An action is typically\n * created from within a Scheduler and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n *\n * @class Action<T>\n */\nvar Action = (function (_super) {\n    __extends(Action, _super);\n    function Action(scheduler, work) {\n        _super.call(this);\n    }\n    /**\n     * Schedules this action on its parent Scheduler for execution. May be passed\n     * some context object, `state`. May happen at some point in the future,\n     * according to the `delay` parameter, if specified.\n     * @param {T} [state] Some contextual data that the `work` function uses when\n     * called by the Scheduler.\n     * @param {number} [delay] Time to wait before executing the work, where the\n     * time unit is implicit and defined by the Scheduler.\n     * @return {void}\n     */\n    Action.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        return this;\n    };\n    return Action;\n}(Subscription_1.Subscription));\nexports.Action = Action;\n//# sourceMappingURL=Action.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/scheduler/Action.js\n// module id = 338\n// module chunks = 0 1 2 3","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar root_1 = require('../util/root');\nvar Action_1 = require('./Action');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AsyncAction = (function (_super) {\n    __extends(AsyncAction, _super);\n    function AsyncAction(scheduler, work) {\n        _super.call(this, scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n        this.pending = false;\n    }\n    AsyncAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        if (this.closed) {\n            return this;\n        }\n        // Always replace the current state with the new state.\n        this.state = state;\n        // Set the pending flag indicating that this action has been scheduled, or\n        // has recursively rescheduled itself.\n        this.pending = true;\n        var id = this.id;\n        var scheduler = this.scheduler;\n        //\n        // Important implementation note:\n        //\n        // Actions only execute once by default, unless rescheduled from within the\n        // scheduled callback. This allows us to implement single and repeat\n        // actions via the same code path, without adding API surface area, as well\n        // as mimic traditional recursion but across asynchronous boundaries.\n        //\n        // However, JS runtimes and timers distinguish between intervals achieved by\n        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n        // serial `setTimeout` calls can be individually delayed, which delays\n        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n        // guarantee the interval callback will be invoked more precisely to the\n        // interval period, regardless of load.\n        //\n        // Therefore, we use `setInterval` to schedule single and repeat actions.\n        // If the action reschedules itself with the same delay, the interval is not\n        // canceled. If the action doesn't reschedule, or reschedules with a\n        // different delay, the interval will be canceled after scheduled callback\n        // execution.\n        //\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, delay);\n        }\n        this.delay = delay;\n        // If this action has already an async Id, don't request a new one.\n        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n        return this;\n    };\n    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);\n    };\n    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        // If this action is rescheduled with the same delay time, don't clear the interval id.\n        if (delay !== null && this.delay === delay && this.pending === false) {\n            return id;\n        }\n        // Otherwise, if the action's delay time is different from the current delay,\n        // or the action has been rescheduled before it's executed, clear the interval id\n        return root_1.root.clearInterval(id) && undefined || undefined;\n    };\n    /**\n     * Immediately executes this action and the `work` it contains.\n     * @return {any}\n     */\n    AsyncAction.prototype.execute = function (state, delay) {\n        if (this.closed) {\n            return new Error('executing a cancelled action');\n        }\n        this.pending = false;\n        var error = this._execute(state, delay);\n        if (error) {\n            return error;\n        }\n        else if (this.pending === false && this.id != null) {\n            // Dequeue if the action didn't reschedule itself. Don't call\n            // unsubscribe(), because the action could reschedule later.\n            // For example:\n            // ```\n            // scheduler.schedule(function doWork(counter) {\n            //   /* ... I'm a busy worker bee ... */\n            //   var originalAction = this;\n            //   /* wait 100ms before rescheduling the action */\n            //   setTimeout(function () {\n            //     originalAction.schedule(counter + 1);\n            //   }, 100);\n            // }, 1000);\n            // ```\n            this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n        }\n    };\n    AsyncAction.prototype._execute = function (state, delay) {\n        var errored = false;\n        var errorValue = undefined;\n        try {\n            this.work(state);\n        }\n        catch (e) {\n            errored = true;\n            errorValue = !!e && e || new Error(e);\n        }\n        if (errored) {\n            this.unsubscribe();\n            return errorValue;\n        }\n    };\n    AsyncAction.prototype._unsubscribe = function () {\n        var id = this.id;\n        var scheduler = this.scheduler;\n        var actions = scheduler.actions;\n        var index = actions.indexOf(this);\n        this.work = null;\n        this.delay = null;\n        this.state = null;\n        this.pending = false;\n        this.scheduler = null;\n        if (index !== -1) {\n            actions.splice(index, 1);\n        }\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, null);\n        }\n    };\n    return AsyncAction;\n}(Action_1.Action));\nexports.AsyncAction = AsyncAction;\n//# sourceMappingURL=AsyncAction.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/scheduler/AsyncAction.js\n// module id = 339\n// module chunks = 0 1 2 3","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Scheduler_1 = require('../Scheduler');\nvar AsyncScheduler = (function (_super) {\n    __extends(AsyncScheduler, _super);\n    function AsyncScheduler() {\n        _super.apply(this, arguments);\n        this.actions = [];\n        /**\n         * A flag to indicate whether the Scheduler is currently executing a batch of\n         * queued actions.\n         * @type {boolean}\n         */\n        this.active = false;\n        /**\n         * An internal ID used to track the latest asynchronous task such as those\n         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n         * others.\n         * @type {any}\n         */\n        this.scheduled = undefined;\n    }\n    AsyncScheduler.prototype.flush = function (action) {\n        var actions = this.actions;\n        if (this.active) {\n            actions.push(action);\n            return;\n        }\n        var error;\n        this.active = true;\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (action = actions.shift()); // exhaust the scheduler queue\n        this.active = false;\n        if (error) {\n            while (action = actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AsyncScheduler;\n}(Scheduler_1.Scheduler));\nexports.AsyncScheduler = AsyncScheduler;\n//# sourceMappingURL=AsyncScheduler.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/scheduler/AsyncScheduler.js\n// module id = 340\n// module chunks = 0 1 2 3","\"use strict\";\nvar AsyncAction_1 = require('./AsyncAction');\nvar AsyncScheduler_1 = require('./AsyncScheduler');\n/**\n *\n * Async Scheduler\n *\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to \"defer\" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asap} scheduler.\n *\n * @example <caption>Use async scheduler to delay task</caption>\n * const task = () => console.log('it works!');\n *\n * Rx.Scheduler.async.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // \"it works!\"\n *\n *\n * @example <caption>Use async scheduler to repeat task in intervals</caption>\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * Rx.Scheduler.async.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n *\n * @static true\n * @name async\n * @owner Scheduler\n */\nexports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);\n//# sourceMappingURL=async.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/scheduler/async.js\n// module id = 341\n// module chunks = 0 1 2 3","import { Component } from '@angular/core';\nimport { IonicPage, NavController, NavParams } from 'ionic-angular';\nimport { UserServiceProvider } from '../../providers/user-service/user-service';\n\n/**\n * Generated class for the MyCollectPage page.\n *\n * See http://ionicframework.com/docs/components/#navigation for more info\n * on Ionic pages and navigation.\n */\n@IonicPage()\n@Component({\n  selector: 'page-my-collect',\n  templateUrl: 'my-collect.html',\n})\nexport class MyCollectPage {\n\n  page1: any = 'CollectWorkPage';\n  page2: any = 'CollectAnswerPage';\n  _id = 0;\n  chatParams = {\n    _id: this._id\n  };\n\n  constructor(public UserService: UserServiceProvider, public navCtrl: NavController, public navParams: NavParams) {\n\n    if (this.navParams.get(\"id\")) {\n      this._id = this.navParams.get(\"id\");\n      this.chatParams._id = this._id;\n    } else {\n      this.chatParams._id = this.UserService._user._id;\n    }\n\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/pages/my-collect/my-collect.ts"],"sourceRoot":""}